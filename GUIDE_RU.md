# Гайд по установке Svelte.

В данном руководстве мы установим Svelte с связке с Routify и напишем небольшое приложение, которое будет отсылать запрос на тестовый сервер в интернете и получать ответ от него.

Онлайн копия данного руководства (возможно немного изменённая) находится по адресу: https://github.com/ravsii/svelte-installation-guide-ru/blob/main/GUIDE_RU.md

## Содержание

- [Гайд по установке Svelte.](#------------------svelte)
  - [Содержание](#----------)
  - [Что это и почему](#----------------)
    - [А зачем Routify?](#--------routify-)
  - [Установка](#---------)
    - [Установка зависимостей](#----------------------)
    - [Установка Svelte](#----------svelte)
      - [Опционально: Tailwind CSS](#-------------tailwind-css)
    - [Тестовый запуск](#---------------)
      - [Tailwind CSS: проверка импорта](#tailwind-css------------------)
  - [Разработка](#----------)
    - [Для пользователей VSCode:](#------------------vscode-)
    * [Как общаться с другими сервисами (Spring в нашем случае)](#----------------------------------spring----------------)
    * [Структура проекта](#-----------------)
    * [\_layout.svelte](#--layoutsvelte-)
    * [Компоненты](#----------)
      - [Отправка данных от ребёнка к родителю](#-------------------------------------)
    * [Вложенные layout](#----------layout)
    * [`bind:...`, `on:...` директивы](#-bind-----on------------)
      - [Привязка данных к переменным](#----------------------------)
      - [Обработчики событий `on:...`](#---------------------on--)
    * [Отправляем запрос](#-----------------)
  - [Полезные ссылки](#---------------)

## Что это и почему

Svelte это фронтэнд фреймворк, который позволяет очень просто и быстро разрабатывать веб-приложения. Если вы слышали о таких вещах как React, AngularJS, то это из этой же серии.

По моему скромному мнению но намного приятнее и удобнее React (Angular сейчас используют заметно реже), из-за своей простоты, но имеет сообщество поменьше. Хотя если у вас возникнут какие-то вопросы, скорее всего в гугле ответ найдётся.

### А зачем Routify?

Svelte, в отличии от своих аналогов, представляет только [реактивность](https://svelte.dev/tutorial/reactive-declarations), работы с компонентами и всё что непосредственно связано с тем, за что отвечает браузер. Однако серверные задачи (такие как создание дополнительных страниц на сайте или роутинг) он выполнять не умеет. Для этого существуют фреймворки, которые реализуют серверную часть для него.

Их список:

- [Svelte Kit](https://kit.svelte.dev/) – официальный фреймворк
- [Sapper](https://sapper.svelte.dev/) - предшественник Svelte Kit
- [Routify](https://www.routify.dev/) - фреймворк от сторонних разработчиков, который специализируется на роутинге.

Routify довольно прост, так делает всего 2 вещи - работу со страницами и вложенные layout (об этом позже), так что нашим требованиям он отвечает.

## Установка

### Установка зависимостей

Скачиваем NodeJS с [официального сайта](https://nodejs.org/en), LTS версии будет достаточно, но можно и самую последнюю версию.

Если установка прошла успешно, то вы должны увидеть следующий результат в консоли

![](/guide_images/node_version.png)

_Если нет - то гуглите текст ошибки, скорее всего до вас кто-то уже сталкивался с подобным_

### Установка Svelte

Так как Svelte мы будем устанавливать в Routify - то мы можем использоваться уже готовый "стартер" проект, который они предоставляют в [официальном репозитории](https://github.com/roxiness/routify-starter).

Создаём папку, где у нас будет хранится проект, заходим туда через консоль и вводим:

```bash
npm init routify
```

![](/guide_images/install_y.png)

Соглашаемся (Пишем: "_y_")

![](/guide_images/install_select.png)

Далее нам предлагают выбрать версию. Выбираем Routify 2 (синий текст) и жмём Enter.

**Важно**: Если вторая версия уже не актуальная, и вам автоматически ставится 3, то в некоторых моментах надо будет самому в доках искать актуальную информацию. Сейчас на Beta версии немного изменён механизм `_layout.svelte`, которые стали модулями, работа с `$url()`, возможно что-то ещё будет изменено.

![](/guide_images/install_dir.png)

Если ваша директория не пуста (как у меня), то вас попросят утвердить, что вы хотите установить проект именно в эту директорию.

_Вполне возможно, что на этом этапе может вылезти ошибка, установите проект в пустую директорию, а потом переместите куда вам нужно_

После установки у вас должны появится папки `public` и `src`, и много всяких файлов.

![](/guide_images/install_ls.png)

#### Опционально: Tailwind CSS

Можно не устанавливать его и писать вёрстку самому, тут уже как хотите. Но данный фреймворк является практически обязательным, если планируете становится Frontend разрабочиком.

Для установки Tailwind воспользуемся двумя источниками, [обычной установкой](https://tailwindcss.com/docs/installation) и [установкой для Vite](https://tailwindcss.com/docs/guides/vite). Второй источник нужен для добавления Tailwind к Vite (серверный фреймворк, который использует Routify).

```bash
npm install -D tailwindcss postcss autoprefixer # Установим зависимости.
npx tailwindcss init # Создаём стандартный конфигурационный файл.
```

Результат:

![](/guide_images/install_tailwind.png)

Из [гайда для SvelteKit](https://tailwindcss.com/docs/guides/sveltekit) укажим, в каких файлах будет работать Tailwind, и запишем это в наш только-что созданный `tailwind.config.js`, который теперь должен выглядеть примерно так:

```typescript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{html,js,svelte,ts}'],
  theme: {
    content: [],
    extend: {},
  },
  plugins: [],
}
```

Далее переходим в `/src/global.css`, удаляем всё оттуда и добавляем директивы импорта Tailwind.

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Далее мы должны импортировать Tailwind в корень Svelte проекта. Заходим в соседний файл `App.svelte` и добавляем в импорт наш `global.css`. Должно получиться как-то так.

```svelte
<script>
  import { Router } from '@roxi/routify'
  import { routes } from '../.routify/routes'
  import './global.css'
</script>

<Router routes="{routes}" />
```

Для корректной загрузки директорий файл `postcss.config.js` необходимо заменить на следующий

```typescript
module.exports = {
  plugins: [require('tailwindcss'), require('autoprefixer')],
}
```

### Тестовый запуск

Перед запуском установить все (возможно отсутствующие) зависимости

```bash
npm i
```

![](/guide_images/test_npm_i.png)

И запустим сервер командой

```bash
npm run dev
```

_Если возникает ошибка: `sh: run-p: command not found`, то попробуйте установить зависимость и снова запустить_

```bash
npm i npm-run-all
```

_Если ошибка другая - тут только гугл_

После запуска сервера должен появится следующий текст

![](/guide_images/test_run.png)

И при заходе на [http://localhost:5000/](http://localhost:5000/) вы должны увидеть стартовую страницу. (Если не устанавливали Tailwind, возможно визуально она будет другая)

![](/guide_images/test_localhost.png)

#### Tailwind CSS: проверка импорта

Проверить его достаточно просто. Во первых, визуально ваша страница должна выглядеть идентично скриншоту выше, хотя это лишь означает что все стили которые мы удаляли - удалились.

Добавим в файл `/src/pages/index/svelte` немного 👍классов👍 и посмотрим на результат. Например, поменяем заголовок на

```svelte
<h1 class="p-4 m-4 text-xl text-red-500 border border-red-500">
  Routify Starter Template
</h1>
```

![](/guide_images/test_tailwind.png)

Если у вас всё идентично - поздравляю.

## Разработка

В этой главе мы напишем максимально простое приложение, которое показывает как принимать и отправлять запросы, добавлять страницы, переходы между ними, работу с компонентами.

#### Для пользователей VSCode:

Установите эти плагины и ваша жизнь сильно облегчится:

- [Svelte for VS Code](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode)
- [Tailwind CSS IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss)
- [Headwind](https://marketplace.visualstudio.com/items?itemName=heybourn.headwind) - Сортировщик классов для TW

### Как общаться с другими сервисами (Spring в нашем случае)

Общение будет происходить через REST-API, которое сервер нам предоставляет. Важный момент, что _все_ общение происходит через API запросы при помощи JSON и клиент не имеет никакого доступа к данным, кроме тех, которые вы посылаете с сервера. Учитывайте это при разработке.

### Структура проекта

Больше всего нас интересует папка `/src`, так как в ней находится весь исходный код.

В изначальном варианте она выглядит как

![](/guide_images/dev_structure.png)

_(Файлы `_fallback.svelte` и вся папка `examples` были удалены за ненадобностью, изначально они у вас будут. Удалять не обязательно)_

`global.css`, `App.svelte` и `main.js` нам не интересны и их лучше не трогать.

В папке `pages` лежат файлы страниц. Файлы, начинающиеся с `_` - особенные, и их показывать в браузере не будет. `index.svelte` доступ как изначальный файл по данному пути и доступен просто по `http://localhost:5000/`. Если создать файл `test.svelte` в этой папке - то он будет доступен по адресу `http://localhost:5000/test`.

![](/guide_images/dev_test_file.png)

### `_layout.svelte`

Это особый файл, который используется как обёртка для всех файлов в текущий папке + рекурсивно для всех подпапок, который позволяет применить к ним общую разметку. Наглядно это можно объяснить так.

![](/guide_images/dev_layout_diag.drawio.png)

Всё в файле layout - будет применено ко всем файлам и дочерним папкам рекурсивно, а заместо тега `<slot>` будет подставлен контент вызываемого файла.

Это очень удобно, когда какой-то элемент необходимо сделать глобальным, например навигацию по сайту.

Используем layout чтобы придать сайту красивый вид и убедимся на этому на страницах `/` и `/test`. (Далее ссылки на страницы будут как ссылки в браузере, а не имена файлов)

`/src/pages/_layout.svelte`

```svelte
<div
  class="flex justify-center min-h-screen from-slate-300 to-orange-300 bg-gradient-to-r place-items-center"
>
  <div
    class="p-4 m-4 bg-white border rounded shadow border-neutral-400 shadow-black/50"
  >
    <slot />
  </div>
</div>
```

`/`

![](/guide_images/dev_layout_index.png)

`/test`

![](/guide_images/dev_layout_test.png)

Удобно, не так ли?

### Компоненты

Компоненты позволяют выносить отдельные (обычно повторяющиеся) элементы в файлы, и потом экспортировать их при необходимости.

Давайте добавим небольшой бар для навигации по сайту.

Создадим папку `/src/components`, чтобы наши компоненты нельзя было отдельно прочитать с браузера.

Создадим 2 файла `NavBar.svelte` для самого бара и `NavTab.svelte` для одной вкладки.

Сразу импортируем в `_layout.svelte` наш бар.

```svelte
<script>
  import NavBar from '../components/NavBar.svelte'
</script>

<div ... >
  <div ... >
    <NavBar />
    ...
```

Тут мы вызвали наш компонент без аргументов (в Svelte аргументы называются `props`).

Разберём код NavBar.

```svelte
<script>
  import NavTab from './NavTab.svelte'

  const tabs = [
    {
      name: 'Главная',
      path: '/',
    },
    {
      name: 'Тест',
      path: '/test',
    },
  ]
</script>

<div class="...">
  {#each tabs as tab}
    <NavTab name="{tab.name}" path="{tab.path}" />
  {/each}
</div>
```

В теге `<script>`, так же как и обычном HTML можно использовать любой клиентский Javascript. В нашем случае - мы объявили константу для меню.

`{#each ...}` - тоже неизвестная конструкция. По сути это обычный цикл `foreach`, который говорит: пройдись по всем `tabs`, и положи каждую из ячеек массива поочерёдно в `tab`.

Svelte позволяет использовать `if`, `foreach` и другие подобные конструкции внутри HTML, позволяя сокращать код и добавлять туда логику.

Подробнее о том какие конструкции есть - в официальной [инструкции](https://svelte.dev/tutorial/if-blocks) в главе Logic.

Далее видно, что в компонент NavTab было передано 2 параметра - наименование и путь ссылки, но как он их принимает?

`NavTab.svelte`

```svelte
<script>
  import { url } from '@roxi/routify'

  export let name, path
</script>

<a href="{$url(path)}" ...>
  {name}
</a>
```

Для начала про `$url`. При использоваии Routify ссылки лучше оборачивать в `$url(...)`, так как он позволяет без перезагрузки менять страницы и использовать относительные пути. `$url("..")` - вернёт вас на директорию выше. Стоит отметить что переходы по ссылкам через `$url` работают как перехода по папкам внутри папки `pages`.

Для вставки JS кода в HTML используйте `{}` скобки. `{name}` при загрузке страницы превратится в название таба и т.п.

Для того чтобы принимать аргументы - необходимо указать что мы экспортируем переменные, в нашем случае:

```svelte
<script>
  export let name, path
//  ^     ^   ^     ^
//  |     |   |     |
//  |     |   Имена переменных
//  |     Объявление переменной(-ых)
//  Ключевое слово для экспортирования переменных
</script>
```

В результате получился такой простой бар с ссылками, на основе которого мы познакомились с компонентами. Стоит заметить, что переход между этими страницами не вызывает обновление страницы, как если бы мы сделали `<a href="/test">...</a>`.

![](/guide_images/dev_tabs_index.png)
![](/guide_images/dev_tabs_test.png)

#### Отправка данных от ребёнка к родителю

В примерах выше мы рассмотрели как пересылать данные от родителя к ребёнку через Props дочернего компонента. Вполне возможно, что вам понадобится пересылать данные от дочернего компонента к родителю.

В таком случае вам стоит обратится к событиям. [Подробнее тут](https://svelte.dev/tutorial/component-events)

Полноценный сценарий есть в примерах, если кратко, то:

```svelte
<!-- child.svelte -->
<script>
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  function sayHello() {
    dispatch('eventName', 'hello');
  }

  sayHello();
</script>

<!-- parent.svelte -->
<script>
  import child from './child.svelte';

  function handleMessage(event) {
    console.log(event.detail)
  }
</script>

<Inner on:eventName={handleMessage} />
```

В коде ребёнка необходимо создать `dispatch()`, отправлять данные им, а на родителе перехватывать эти событий через `on:eventName`, где `eventName` - это первый аргумент функции `dispatch`.

### Вложенные layout

Создадим новую папку, в которой будет содержаться ещё один `_layout.svelte`, и `index.svelte`, а папку назовём `restTest`. Так же добавим данный путь в нашу навигацию.

![](/guide_images/dev_rest_layout.png)

Как видим, `/restTest/index.svelte` обёрнут уже в 2 файла `_layout`, основной, и тот что находится в папке.

Сверстаем небольшой макет. Слева мы можем ввести свой запрос, а справа мы будем видеть ответ на наш запрос.

![](/guide_images/dev_rest_blocks.png)

### `bind:...`, `on:...` директивы

Прежде чем отправить запрос, нам необходимо как-то получить информацию, которую ввёл пользователь, а так же совершать действие отправки этой информации по клику кнопки

#### Привязка данных к переменным

Для того чтобы привязать вводимую информацию к какой-то переменной, который будет обновляться каждый раз, как изменяется поле ввода, нам необходимо использовать директиву `bind`.

```svelte
<script>
  //...
  let value
  //...
</script>

<div ... >
  <div ... >
    <textarea bind:value="{value}" ...></textarea>
```

Теперь, когда мы не обратились к переменной `value` - в ней всегда будет лежать то, что написано в блоке ввода.

Это работает и в обратную сторону. `value = "123"` установит значение в блоке ввода `123`.

#### Обработчики событий `on:...`

Следующей нашей задачей является привязать событие клика к какому-то действию. В Svelte это делается очень просто.

```svelte
<script>
  function handleSendRequest() {
    alert('Я вызвался при клике')
  }
</script>

<div ... >
  <div ... >
    ...
    <button on:click="{handleSendRequest}" ... >
      Отправить запрос
    </button>
```

Теперь каждый раз при клике на кнопку будет вызываться функция `handleSendRequest()`.

**ОЧЕНЬ ВАЖНО:** В `on:click` необходимо писать название функции **БЕЗ** скобок, иначе произойдёт вызов сразу после загрузки страницы.

Теперь при клике у нас срабатывает обработчик

![](/guide_images/dev_rest_onclick.png)

### Отправляем запрос

Изменим функцию при клике, чтобы отправлять запрос.

```javascript
async function handleSendRequest() {
  const res = await fetch('https://echo.zuplo.io/', {
    method: 'POST', // Метод
    body: JSON.stringify(value), // Тело запроса. Обязательно в виде строки
  })
  const resJson = await res.json()

  // Дополнительные проверки resJson, какая-то логика

  responseJson = resJson
}
```

И при клике получим ответ.

![](/guide_images/dev_request_success.png)

Данный JSON приходит в виде объекта, поэтому вы можете обращаться к его полям. Например `responseJson.body` вернёт вам ваш запрос, который вы отправили.

Надеюсь данное руководство было вам полезно.

## Полезные ссылки

В основном ссылки на офф. доки, потому что по большинству вопросов там есть ответы, стоит лишь поискать.

- https://www.google.com/
- https://svelte.dev/tutorial/basics - Официальный гайд по всем возможностям. Есть версия на русском [тут](https://ru.svelte.dev/tutorial/basics), однако обычно там ошибка, если заходить без ВПН.
- https://tailwindcss.com/ - Все классы Tailwind
- https://daisyui.com/ - Обёртка поверх Tailwind, в которой есть готовые компоненты. Несколько упрощает жизнь.
