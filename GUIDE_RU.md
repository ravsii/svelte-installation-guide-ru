# Гайд по установке Svelte.

В данном руководстве мы установим Svelte с связке с Routify и напишем небольшое приложение, которое будет отсылать запрос на тестовый сервер в интернете и получать ответ от него.

Онлайн копия данного руководства (возможно c изменениями) находится по адресу: https://github.com/ravsii/svelte-installation-guide-ru/blob/main/GUIDE_RU.md

## Содержание

- [Гайд по установке Svelte.](#гайд-по-установке-svelte.)
  - [Содержание](#содержание)
  - [Что это и почему](#что-это-и-почему)
    - [А зачем Routify?](#а-зачем-routify?)
  - [Установка](#установка)
    - [Установка зависимостей](#установка-зависимостей)
    - [Установка Svelte](#установка-svelte)
      - [Опционально](#-tailwind-css)
    - [Тестовый запуск](#тестовый-запуск)
      - [Tailwind CSS](#-проверка-импорта)
  - [Разработка](#разработка)
    - [Для пользователей VSCode](#)
    - [Как общаться с другими сервисами (Spring в нашем случае)](<#как-общаться-с-другими-сервисами-(spring-в-нашем-случае)>)
    - [Структура проекта](#структура-проекта)
    - [Файлы `_layout.svelte`](#файлы-`_layout.svelte`)
    - [Компоненты](#компоненты)
      - [Отправка данных от ребёнка к родителю](#отправка-данных-от-ребёнка-к-родителю)
    - [Вложенные layout](#вложенные-layout)
    - [Директивы `bind`, `on`](#директивы-`bind`,-`on`)
      - [Привязка данных к переменным](#привязка-данных-к-переменным)
      - [Обработчики событий `on](#...`)
    - [Отправляем запрос](#отправляем-запрос)
  - [Полезные ссылки](#полезные-ссылки)

## Что это и почему

Svelte это фронтэнд фреймворк, который позволяет очень просто и быстро разрабатывать веб-приложения. Если вы слышали о таких вещах как React, AngularJS, то это из этой же серии.

По моему скромному мнению Svelte намного приятнее и удобнее React, а Angular в целом сейчас используют гораздо реже. Он довольно простой в освоении, хоть и имеет комьюнити поменьше, что немного влияет на количество доступной информации и количество модулей от сторонних разработчиков.

### А зачем Routify?

Svelte, в отличии от своих аналогов, представляет только [реактивность](https://svelte.dev/tutorial/reactive-declarations), работы с компонентами и всё что непосредственно связано с тем, за что отвечает браузер. Однако серверные задачи (такие как создание дополнительных страниц на сайте или роутинг) он выполнять не умеет. Для этого существуют фреймворки, которые реализуют серверную часть для него.

Их список:

- [Svelte Kit](https://kit.svelte.dev/) – официальный фреймворк
- [Sapper](https://sapper.svelte.dev/) - предшественник Svelte Kit
- [Routify](https://www.routify.dev/) - фреймворк от сторонних разработчиков, который специализируется на роутинге.

Routify довольно прост, так как делает работу со страницами простой в использовании. Он так же даёт возможность использовать вложенные layout (об этом позже). Больше нам от серверной части на фронтэнде ничего не требуется, так что нашим требованиям он отвечает.

## Установка

### Установка зависимостей

Скачиваем NodeJS с [официального сайта](https://nodejs.org/en), LTS версии будет достаточно, но можно и самую последнюю версию.

Если установка прошла успешно, то вы должны увидеть следующий результат в консоли.

_Зайти в консоль на windows можно комбинацией клавиш `Win+R` а затем `cmd.exe`, либо `Shift+ПКМ` внутри любой папки по пустому месту, а затем `Открыть окно PowerShell` либо что-то подобное, если у вас Windows 7 либо ниже._

![](/guide_images/node_version.png)

Версия не обязательно должна совпадать с той что на скриншоте.

_Если нет - то гуглите текст ошибки, скорее всего до вас кто-то уже сталкивался с подобным._

### Установка Svelte

Так как Svelte мы будем устанавливать в Routify - мы можем использовать уже готовый "стартер" проект, который они предоставляют в [официальном репозитории](https://github.com/roxiness/routify-starter).

Создаём папку, где у нас будет хранится проект, заходим туда через консоль и вводим:

```bash
npm init routify
```

![](/guide_images/install_y.png)

Соглашаемся (Пишем: "_y_" английскую).

![](/guide_images/install_select.png)

Далее нам предлагают выбрать версию. Выбираем Routify 2 (синий текст) и жмём Enter.

**Важно**: Если вторая версия уже не актуальная, и вам автоматически ставится 3, то в некоторых моментах надо будет самому в доках искать актуальную информацию. Сейчас на Beta версии изменено поведение `_layout.svelte`, которые стали модулями, работа с `$url()`, возможно что-то ещё будет изменено.

![](/guide_images/install_dir.png)

Если ваша директория не пустая (как у меня), то вас попросят утвердить, что вы хотите установить проект именно в эту директорию.

_Вполне возможно, что на этом этапе может вылезти ошибка, установите проект в пустую директорию, а потом переместите куда вам нужно._

После установки у вас должны появится папки `public` и `src`, и много всяких файлов.

![](/guide_images/install_ls.png)

#### Опционально: Tailwind CSS

Можно не устанавливать его и писать вёрстку самому, тут уже как хотите. Но данный фреймворк является практически обязательным, если планируете становится Frontend разрабочиком.

Для установки Tailwind воспользуемся двумя источниками, [обычной установкой](https://tailwindcss.com/docs/installation) и [установкой для Vite](https://tailwindcss.com/docs/guides/vite). Второй источник нужен для добавления Tailwind к Vite (серверный фреймворк, который использует Routify).

```bash
npm install -D tailwindcss postcss autoprefixer # Установим зависимости.
npx tailwindcss init # Создаём стандартный конфигурационный файл.
```

Результат:

![](/guide_images/install_tailwind.png)

Из [гайда для SvelteKit](https://tailwindcss.com/docs/guides/sveltekit) укажем, в каких файлах будет работать Tailwind, и запишем это в наш только-что созданный `tailwind.config.js`, который теперь должен выглядеть примерно так:

```typescript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{html,js,svelte,ts}'],
  theme: {
    content: [],
    extend: {},
  },
  plugins: [],
}
```

Далее переходим в `/src/global.css`, удаляем всё оттуда и добавляем директивы импорта Tailwind.

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Далее мы должны импортировать Tailwind в корень Svelte проекта. Заходим в соседний файл `App.svelte` и добавляем в импорт наш `global.css`.

```svelte
<script>
  import { Router } from '@roxi/routify'
  import { routes } from '../.routify/routes'
  import './global.css'
</script>

<Router routes="{routes}" />
```

Для корректной работы Tailwind директорий текст в файле `postcss.config.js` необходимо заменить на следующий:

```typescript
module.exports = {
  plugins: [require('tailwindcss'), require('autoprefixer')],
}
```

### Тестовый запуск

Перед запуском установить все (возможно отсутствующие) зависимости:

```bash
npm i
```

![](/guide_images/test_npm_i.png)

И запустим сервер командой:

```bash
npm run dev
```

_Если возникает ошибка: `sh: run-p: command not found`, то попробуйте установить зависимость и снова запустить:_

```bash
npm i npm-run-all
```

_Если ошибка другая - тут только гугл._

После запуска сервера должен появится следующий текст.

![](/guide_images/test_run.png)

И при заходе на [http://localhost:5000/](http://localhost:5000/) вы должны увидеть стартовую страницу. (Если не устанавливали Tailwind, возможно визуально она будет другая).

![](/guide_images/test_localhost.png)

#### Tailwind CSS: проверка импорта

Проверить его достаточно просто. Во первых, визуально ваша страница должна выглядеть идентично скриншоту выше, хотя это лишь означает, что все стили которые мы удаляли - удалились.

Добавим в файл `/src/pages/index.svelte` немного 👍классов👍 и посмотрим на результат. Например, поменяем заголовок на:

```svelte
<h1 class="p-4 m-4 text-xl text-red-500 border border-red-500">
  Routify Starter Template
</h1>
```

Перезапускать сервер не нужно. Если вы запускали его с помощью `npm run dev`, то все изменения будут обновляться автоматически.

![](/guide_images/test_tailwind.png)

Если у вас всё идентично - поздравляю.

## Разработка

В этой главе мы напишем максимально простое приложение, которое показывает как принимать и отправлять запросы, добавлять страницы, переходы между ними, работу с компонентами.

#### Для пользователей VSCode:

Установите эти плагины и ваша жизнь сильно облегчится:

- [Svelte for VS Code](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode)
- [Tailwind CSS IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss)
- [Headwind](https://marketplace.visualstudio.com/items?itemName=heybourn.headwind) - Сортировщик классов для TW

### Как общаться с другими сервисами (Spring в нашем случае)

Общение будет происходить через REST-API, которое сервер нам предоставляет. Важный момент, что _всё_ общение происходит через API-запросы с помощью JSON, и фронтэнд не имеет никакого доступа к данным, кроме тех, которые вы посылаете с сервера. Учитывайте это при разработке.

### Структура проекта

Больше всего нас интересует папка `/src`, так как в ней находится весь исходный код.

В изначальном варианте она выглядит так.

![](/guide_images/dev_structure.png)

_Файлы `_fallback.svelte` и вся папка `example` были удалены за ненадобностью, изначально они у вас будут. Удалять не обязательно._

`global.css`, `App.svelte` и `main.js` нам не интересны и их лучше не трогать.

В папке `pages` лежат файлы страниц. Файлы, начинающиеся с `_` - особенные, и их показывать в браузере не будет. `index.svelte` доступен как изначальный файл по данному пути и доступен просто по `http://localhost:5000/`. Если создать файл `/src/pages/test.svelte` - то он будет доступен по адресу: `http://localhost:5000/test`.

![](/guide_images/dev_test_file.png)

### Файлы `_layout.svelte`

Это особый файл, который используется как обёртка для всех файлов в текущий папке + рекурсивно для всех подпапок, который позволяет применить к ним общую разметку. Наглядно это можно объяснить так.

![](/guide_images/dev_layout_diag.drawio.png)

Всё в файле layout - будет применено ко всем файлам и дочерним папкам рекурсивно, а вместо тега `<slot>` будет подставлен контент вызываемого файла.

Это очень удобно, когда какой-то элемент необходимо сделать глобальным, например навигацию, по сайту.

Используем layout чтобы придать сайту красивый вид и убедимся этому на страницах `/` и `/test`.

`/src/pages/_layout.svelte`

```svelte
<div
  class="flex justify-center min-h-screen from-slate-300 to-orange-300 bg-gradient-to-r place-items-center"
>
  <div
    class="p-4 m-4 bg-white border rounded shadow border-neutral-400 shadow-black/50"
  >
    <slot />
  </div>
</div>
```

Путь `/`

![](/guide_images/dev_layout_index.png)

Путь `/test`

![](/guide_images/dev_layout_test.png)

Удобно, не так ли?

### Компоненты

Компоненты позволяют выносить отдельные (обычно повторяющиеся) элементы в файлы, и потом импортировать их при необходимости.

Давайте добавим небольшой бар для навигации по сайту.

Создадим папку `/src/components`, чтобы наши компоненты нельзя было отдельно просмотреть с браузера.

Создадим 2 файла `NavBar.svelte` для самого бара и `NavTab.svelte` для одной вкладки(ссылки).

Сразу импортируем в `_layout.svelte` наш бар.

```svelte
<script>
  import NavBar from '../components/NavBar.svelte'
</script>

<div ... >
  <div ... >
    <NavBar />
    ...
```

Тут мы вызвали наш компонент без аргументов (в Svelte аргументы называются `props`).

Разберём код `NavBar.svelte`.

```svelte
<script>
  import NavTab from './NavTab.svelte'

  const tabs = [
    {
      name: 'Главная',
      path: '/',
    },
    {
      name: 'Тест',
      path: '/test',
    },
  ]
</script>

<div class="...">
  {#each tabs as tab}
    <NavTab name="{tab.name}" path="{tab.path}" />
  {/each}
</div>
```

В теге `<script>`, так же как и обычном HTML, можно использовать любой клиентский Javascript. В нашем случае - мы объявили константу для хранения элементов меню.

`{#each ...}` - тоже неизвестная до этой поры конструкция. По сути это обычный цикл `foreach`, который говорит: пройдись по всем `tabs`, и положи каждую из ячеек массива поочерёдно в `tab`.

Svelte позволяет использовать `if`, `foreach` и другие подобные конструкции внутри HTML, позволяя сокращать код и добавлять туда логику.

Подробнее о том какие конструкции есть - в официальной [инструкции](https://svelte.dev/tutorial/if-blocks) в главе Logic.

Далее видно, что в компонент `NavTab` было передано 2 параметра - наименование и путь ссылки, но как он их принимает?

`NavTab.svelte`

```svelte
<script>
  import { url } from '@roxi/routify'

  export let name, path
</script>

<a href="{$url(path)}" ...>
  {name}
</a>
```

Для начала про `$url`. При использоваии Routify ссылки лучше оборачивать в `$url(...)`, так как он позволяет без перезагрузки менять страницы и использовать относительные пути. `$url("..")` - вернёт вас на директорию выше. Стоит отметить, что переходы по ссылкам через `$url` работают как переходы по папкам внутри папки `pages`.

Для вставки JS кода в HTML используйте `{}` скобки. `{name}` при загрузке страницы превратится в название элемента меню и т.п.

Для того чтобы принимать аргументы - необходимо указать, что мы экспортируем переменные, в нашем случае:

```svelte
<script>
  export let name, path
//  ^     ^   ^     ^
//  |     |   |     |
//  |     |   Имена переменных
//  |     Объявление переменной(-ых)
//  Ключевое слово для экспортирования переменных
</script>
```

В результате получился такой простой бар с ссылками, на основе которого мы познакомились с компонентами. Стоит заметить, что переход между этими страницами не вызывает обновление страницы, как если бы мы сделали `<a href="/test">...</a>`.

![](/guide_images/dev_tabs_index.png)
![](/guide_images/dev_tabs_test.png)

#### Отправка данных от ребёнка к родителю

В примерах выше мы рассмотрели как пересылать данные от родителя к ребёнку через Props дочернего компонента. Вполне возможно, что вам понадобится пересылать данные от дочернего компонента к родителю.

В таком случае вам стоит обратиться к событиям. [Подробнее тут](https://svelte.dev/tutorial/component-events)

Полноценный сценарий есть в примерах, если кратко, то:

```svelte
<!-- child.svelte -->
<script>
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  function sayHello() {
    dispatch('eventName', 'hello');
  }

  sayHello();
</script>

<!-- parent.svelte -->
<script>
  import child from './child.svelte';

  function handleMessage(event) {
    console.log(event.detail)
  }
</script>

<Inner on:eventName={handleMessage} />
```

В коде ребёнка необходимо создать `dispatch()`, отправлять данные с помощью данной функции, а на родителе перехватывать эти события через `on:eventName`, где `eventName` - это первый аргумент функции `dispatch`.

### Вложенные layout

Создадим новую папку, в которой будет содержаться ещё один `_layout.svelte`, и `index.svelte`, а папку назовём `restTest`. Так же добавим данную папку в нашу навигацию в `NavBar.svelte`.

```javascript
const tabs = [
    ...,
    {
      name: 'Отправить тестовый запрос',
      path: '/restTest',
    },
  ]
```

![](/guide_images/dev_rest_layout.png)

Как видим, `/restTest/index.svelte` обёрнут уже в 2 файла `_layout`, основной, и тот что находится в папке.

Сверстаем небольшой макет. Слева мы можем ввести свой запрос, а справа мы будем видеть ответ на наш запрос.

![](/guide_images/dev_rest_blocks.png)

### Директивы `bind`, `on`

Прежде чем отправить запрос, нам необходимо как-то получить информацию, которую ввёл пользователь, а так же совершать действие отправки этой информации по клику кнопки

#### Привязка данных к переменным

Для того чтобы привязать вводимую информацию к какой-то переменной, который будет обновляться каждый раз, как изменяется поле ввода, нам необходимо использовать директиву `bind`.

```svelte
<script>
  //...
  let value
  //...
</script>

<div ... >
  <div ... >
    <textarea bind:value="{value}" ...></textarea>
```

Теперь, когда мы не обратились к переменной `value` - в ней всегда будет лежать то, что написано в блоке ввода.

Это работает и в обратную сторону. `value = "123"` установит значение в блоке ввода `123`.

#### Обработчики событий `on:...`

Следующей нашей задачей является привязать событие клика к какому-то действию. В Svelte это делается очень просто.

```svelte
<script>
  function handleSendRequest() {
    alert('Я вызвался при клике')
  }
</script>

<div ... >
  <div ... >
    ...
    <button on:click="{handleSendRequest}" ... >
      Отправить запрос
    </button>
```

Теперь каждый раз при клике на кнопку будет вызываться функция `handleSendRequest()`.

**ОЧЕНЬ ВАЖНО:** В `on:click` необходимо писать название функции **БЕЗ** скобок, иначе произойдёт вызов сразу после загрузки страницы.

Теперь при клике у нас срабатывает обработчик

![](/guide_images/dev_rest_onclick.png)

### Отправляем запрос

Изменим функцию при клике, чтобы отправлять запрос.

```javascript
async function handleSendRequest() {
  const res = await fetch('https://echo.zuplo.io/', {
    method: 'POST', // Метод
    body: JSON.stringify(value), // Тело запроса. Обязательно в виде строки
  })
  const resJson = await res.json()

  // Дополнительные проверки resJson, какая-то логика

  responseJson = resJson
}
```

И при клике получим ответ.

![](/guide_images/dev_request_success.png)

Данный JSON приходит в виде объекта, поэтому вы можете обращаться к его полям. Например `responseJson.body` вернёт вам ваш запрос, который вы отправили.

Надеюсь данное руководство было вам полезно.

## Полезные ссылки

В основном ссылки на офф. доки, потому что по большинству вопросов там есть ответы, стоит лишь поискать.

- https://www.google.com/
- https://svelte.dev/tutorial/basics - Официальный гайд по всем возможностям. Есть версия на русском [тут](https://ru.svelte.dev/tutorial/basics), однако обычно там ошибка, если заходить без ВПН.
- https://tailwindcss.com/ - Все классы Tailwind
- https://daisyui.com/ - Обёртка поверх Tailwind, в которой есть готовые компоненты. Несколько упрощает жизнь.
